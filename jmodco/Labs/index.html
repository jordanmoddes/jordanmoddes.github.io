<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Jmod Labs — Procedural Neural Circuit Background</title>
<style>
  :root{
    /* Tuning knobs */
    --panel-opacity:.88;
    --bg-a:#080d15;       /* deep space */
    --bg-b:#0b1122;       /* deep blue */
    --cyan:#69e6ff;       /* neon cyan */
    --blue:#2aa8ff;       /* electric blue */
    --violet:#b06aff;     /* vibrant violet */
    --pink:#ff7de3;       /* hot pink */
    --ink:#e8f0ff;
  }

  html,body{height:100%}
  body{
    margin:0; background:linear-gradient(180deg,var(--bg-a),var(--bg-b));
    color:var(--ink); font:16px/1.45 Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Arial;
    overflow-x:hidden;
  }

  /* Background canvas stack */
  .bg-wrap{position:fixed; inset:0; z-index:-1; isolation:isolate}
  canvas#neuro{position:absolute; inset:0; width:100%; height:100%;}

  /* Optional example content container (safe to delete) */
  .demo-card{
    max-width:1100px; margin:8vh auto; padding:32px; border-radius:18px;
    background:rgba(16,20,32,var(--panel-opacity)); border:1px solid rgba(201,208,221,.18);
    box-shadow:0 12px 40px rgba(0,0,0,.45);
  }
  h1{margin:0 0 10px; font-size:clamp(28px,4.5vw,48px)}
  p{color:#c8d3ea; margin:.4rem 0 0}
</style>
</head>
<body>

<!-- Procedural background -->
<div class="bg-wrap">
  <canvas id="neuro"></canvas>
</div>

<!-- Demo content (remove/replace with your real Labs markup) -->
<section class="demo-card">
  <h1>Engineering tomorrow’s systems — today.</h1>
  <p>Procedural background: brain particles + neon circuits + energy pulse. No images.</p>
</section>

<script>
(() => {
  const c = document.getElementById('neuro');
  const ctx = c.getContext('2d', { alpha:true });

  // ---------- DPI / Resize ----------
  let DPR = Math.min(1.5, window.devicePixelRatio || 1); // cap for perf
  function size() {
    const { innerWidth:w, innerHeight:h } = window;
    c.width  = Math.floor(w * DPR);
    c.height = Math.floor(h * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
    initScene();
  }
  window.addEventListener('resize', size, {passive:true});

  // ---------- Scene state ----------
  let W=0,H=0,CX=0,CY=0, R=0;
  let brainMask;        // Path2D for brain silhouette
  let particles=[];     // brain particles
  let links=[];         // occasional particle links
  let traces=[];        // circuit traces
  let nodes=[];         // chip nodes
  let t0=performance.now();
  let waveR=0;          // outward blast radius
  let pulsePhase=0;     // vertical beam pulse
  let lastBuildW=0,lastBuildH=0;

  const isMobile = () => Math.min(window.innerWidth, window.innerHeight) < 860;

  // ---------- Utilities ----------
  const rand=(a=1,b=0)=>Math.random()*(b-a)+a;
  const lerp=(a,b,t)=>a+(b-a)*t;
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const dist=(x1,y1,x2,y2)=>Math.hypot(x2-x1,y2-y1);

  // Simple 2D value noise (hash-based) for subtle wobble
  function vnoise(x,y,s=43758.5453123){
    const n = Math.sin(x*12.9898 + y*78.233)*s;
    return n - Math.floor(n);
  }

  // ---------- Brain Shape (Path2D) ----------
  function makeBrainPath(cx,cy,scale){
    const p = new Path2D();
    // abstracted lobed silhouette (hand-tuned Beziers)
    const x=cx, y=cy-0.12*scale, s=scale;
    p.moveTo(x-0.48*s, y+0.05*s);
    p.bezierCurveTo(x-0.65*s, y-0.28*s, x-0.15*s, y-0.55*s, x+0.06*s, y-0.52*s);
    p.bezierCurveTo(x+0.22*s, y-0.58*s, x+0.55*s, y-0.42*s, x+0.52*s, y-0.08*s);
    p.bezierCurveTo(x+0.58*s, y+0.20*s, x+0.35*s, y+0.26*s, x+0.24*s, y+0.28*s);
    p.bezierCurveTo(x+0.10*s, y+0.52*s, x-0.06*s, y+0.58*s, x-0.20*s, y+0.36*s);
    p.bezierCurveTo(x-0.36*s, y+0.44*s, x-0.58*s, y+0.28*s, x-0.48*s, y+0.05*s);
    p.closePath();
    return p;
  }

  // ---------- Particles inside brain ----------
  function seedParticles() {
    particles.length = 0; links.length = 0;
    const count = isMobile() ? 380 : 900;
    // Use isPointInPath to keep inside brain shape
    for (let i=0;i<count;i++){
      let px,py,tries=0;
      do{
        const a = rand(0,Math.PI*2);
        const r = Math.pow(Math.random(),.35)*R*0.55;
        px = CX + Math.cos(a)*r + rand(-6,6);
        py = CY + Math.sin(a)*r*0.7 + rand(-6,6);
        tries++;
      } while(!ctx.isPointInPath(brainMask, px, py) && tries<20);
      const ang = Math.atan2(CY-py,CX-px) + rand(-.8,.8);
      const speed = rand(0.15,0.6);
      particles.push({
        x:px, y:py, vx:Math.cos(ang)*speed, vy:Math.sin(ang)*speed,
        life:rand(0,1), hue: lerp(195, 290, Math.random()),
      });
    }
    // Create faint “neural links”
    for(let i=0;i<Math.floor(particles.length*0.08);i++){
      const a=(Math.random()*particles.length)|0, b=(Math.random()*particles.length)|0;
      if (a!==b) links.push([a,b, Math.random()*0.6+0.2]);
    }
  }

  // ---------- Circuit board ----------
  function buildBoard(){
    traces.length=0; nodes.length=0;

    // Nodes (chips)
    const nCount = isMobile()? 5:10;
    for(let i=0;i<nCount;i++){
      const r = lerp(R*0.9, Math.min(W,H)*0.55, Math.random());
      const th = Math.random()*Math.PI*2;
      const nx = CX + Math.cos(th)*r;
      const ny = CY + Math.sin(th)*r*0.75 + 40;
      nodes.push({x:nx,y:ny,s:rand(14,26), glow:rand(0.3,0.8)});
    }

    // Traces: curves radiating & meandering
    const tCount = isMobile()? 80:160;
    for(let i=0;i<tCount;i++){
      const a = Math.random()*Math.PI*2;
      const r0 = rand(R*0.25, R*0.5);
      const r1 = rand(R*0.6,  Math.min(W,H)*0.6);
      const x0 = CX + Math.cos(a)*r0;
      const y0 = CY + Math.sin(a)*r0*0.7 + 10;
      const x1 = CX + Math.cos(a)*r1 + rand(-40,40);
      const y1 = CY + Math.sin(a)*r1*0.75 + 60 + rand(-30,30);
      // two control points for soft meander
      const midx = (x0+x1)/2 + rand(-80,80);
      const midy = (y0+y1)/2 + rand(-50,50);
      traces.push({
        x0,y0, x1,y1, cx:midx, cy:midy,
        w: rand(0.7,1.8), hue: lerp(200,285,Math.random()),
      });
    }
  }

  // ---------- Initialize / Rebuild on size ----------
  function initScene(){
    W = window.innerWidth;
    H = window.innerHeight;
    CX = W*0.5;
    CY = H*0.42;
    R = Math.min(W,H)*0.55;

    brainMask = makeBrainPath(CX, CY, Math.min(W,H)*0.85);
    seedParticles();
    buildBoard();
    waveR = 0;
    pulsePhase = 0;
    lastBuildW=W; lastBuildH=H;
  }

  size();

  // ---------- Draw helpers ----------
  function glowCircle(x,y,r, colorStop=[['#ffffff',0],['#69e6ff',0.25],['rgba(0,0,0,0)',1]]){
    const g = ctx.createRadialGradient(x,y,0, x,y,r);
    for(const [col,stop] of colorStop){ g.addColorStop(stop,col); }
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  }

  function drawBrain(now){
    // Core glow + “beam” downward
    const beat = 0.5 + Math.sin(now*0.002)*0.5; // 0..1
    glowCircle(CX,CY, Math.min(W,H)*0.18 * (0.9+beat*0.12),
      [['rgba(255,255,255,.95)',0], ['rgba(105,230,255,.55)',0.15], ['rgba(176,106,255,.25)',0.35], ['rgba(0,0,0,0)',1]]
    );

    // beam
    pulsePhase = (now*0.0015) % 1; // 0..1 repeating
    const beamH = H*0.55;
    const beamW = Math.min(W,900)*0.18*(0.85+beat*0.15);
    const y0 = CY; const y1 = CY + beamH;
    const grad = ctx.createLinearGradient(CX,y0,CX,y1);
    grad.addColorStop(0, 'rgba(255,255,255,.85)');
    grad.addColorStop(0.25, 'rgba(105,230,255,.55)');
    grad.addColorStop(0.6, 'rgba(105,230,255,.12)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.globalCompositeOperation = 'lighter';
    ctx.beginPath();
    ctx.moveTo(CX-beamW*0.38, y0);
    ctx.quadraticCurveTo(CX, y0 + beamH*0.15, CX-beamW*0.12, y1);
    ctx.lineTo(CX+beamW*0.12, y1);
    ctx.quadraticCurveTo(CX, y0 + beamH*0.15, CX+beamW*0.38, y0);
    ctx.closePath(); ctx.fill();
    ctx.globalCompositeOperation = 'source-over';

    // Particle field clipped to brain
    ctx.save();
    ctx.clip(brainMask);

    // particle glow pass (additive)
    ctx.globalCompositeOperation = 'lighter';
    for(const p of particles){
      p.x += p.vx * (0.6 + Math.sin((now*0.001 + p.life)*2)*0.15);
      p.y += p.vy * (0.6 + Math.cos((now*0.0015 + p.life)*2)*0.15);

      // soft confinement toward center if out of mask
      if(!ctx.isPointInPath(brainMask, p.x, p.y)){
        const ang = Math.atan2(CY-p.y, CX-p.x);
        p.vx = Math.cos(ang)*0.7;
        p.vy = Math.sin(ang)*0.7;
        p.x += p.vx*3; p.y += p.vy*3;
      }

      const sz = 1.2 + Math.sin((p.life + now*0.002)*6)*0.6;
      ctx.fillStyle = `hsla(${p.hue},100%,70%,.55)`;
      ctx.beginPath(); ctx.arc(p.x, p.y, sz, 0, Math.PI*2); ctx.fill();
      p.life += 0.004;
    }

    // occasional neural links
    ctx.lineWidth = 0.8;
    for(const [ai,bi,alpha] of links){
      const a = particles[ai], b=particles[bi];
      if(!a||!b) continue;
      ctx.strokeStyle = `rgba(150,220,255,${0.12*alpha})`;
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
    }

    ctx.restore();
    ctx.globalCompositeOperation = 'source-over';

    // thin brain outline
    ctx.strokeStyle = 'rgba(200,240,255,.28)';
    ctx.lineWidth = 1.4;
    ctx.stroke(brainMask);
  }

  function drawBoard(now){
    // blurred far “depth” dots
    for(let i=0;i<18;i++){
      const bx = (i*137) % W;
      const by = ((i*83)+100) % H;
      glowCircle(bx, by, 18, [['rgba(110,232,255,.35)',0],['rgba(0,0,0,0)',1]]);
    }

    // outward wave radius from chip contact
    const cycle = 4500; // ms per blast
    const phase = (now % cycle) / cycle; // 0..1
    waveR = lerp(40, Math.hypot(W,H), phase);

    // main glowing traces
    ctx.lineCap = 'round';
    for(const tr of traces){
      // wave highlight factor by distance of midpoint
      const mx = (tr.x0+tr.x1+tr.cx)/3, my=(tr.y0+tr.y1+tr.cy)/3;
      const d = dist(CX, CY+H*0.18, mx, my);
      const wave = Math.max(0, 1 - Math.abs(d-waveR)/70);

      const hue = tr.hue;
      const lw = tr.w + wave*1.4;
      ctx.lineWidth = lw;

      // base glow path
      ctx.strokeStyle = `hsla(${hue}, 100%, 65%, ${0.22 + wave*0.5})`;
      ctx.beginPath();
      ctx.moveTo(tr.x0, tr.y0);
      ctx.quadraticCurveTo(tr.cx, tr.cy, tr.x1, tr.y1);
      ctx.stroke();

      // bright core line
      ctx.lineWidth = Math.max(0.6, lw*0.45);
      ctx.strokeStyle = `hsla(${lerp(200,290,wave)}, 100%, ${lerp(75,90,wave*0.7)}%, ${0.25+wave*0.35})`;
      ctx.stroke();
    }

    // nodes (chips)
    for(const n of nodes){
      const s = n.s;
      const r = s*0.35;
      const g = ctx.createRadialGradient(n.x,n.y,0, n.x,n.y,r*3.2);
      g.addColorStop(0, `rgba(255,255,255,${0.22*n.glow})`);
      g.addColorStop(0.25, `rgba(105,230,255,${0.20*n.glow})`);
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle=g; ctx.beginPath(); ctx.arc(n.x,n.y,r*3.2,0,Math.PI*2); ctx.fill();

      ctx.fillStyle='rgba(22,28,45,.9)';
      ctx.strokeStyle='rgba(180,220,255,.22)';
      ctx.lineWidth=1;
      ctx.beginPath(); ctx.roundRect?.(n.x-s/2, n.y-s/2, s, s, 4);
      if(!ctx.roundRect){ // fallback
        ctx.rect(n.x-s/2, n.y-s/2, s, s);
      }
      ctx.fill(); ctx.stroke();

      // little pins
      ctx.strokeStyle='rgba(110,232,255,.35)';
      ctx.lineWidth=1;
      ctx.beginPath();
      ctx.moveTo(n.x-s/2, n.y); ctx.lineTo(n.x-s/2-10, n.y);
      ctx.moveTo(n.x+s/2, n.y); ctx.lineTo(n.x+s/2+10, n.y);
      ctx.moveTo(n.x, n.y+s/2); ctx.lineTo(n.x, n.y+s/2+10);
      ctx.moveTo(n.x, n.y-s/2); ctx.lineTo(n.x, n.y-s/2-10);
      ctx.stroke();
    }
  }

  function vignette(){
    const grd = ctx.createRadialGradient(CX, H*0.45, Math.min(W,H)*0.4, CX, H*0.45, Math.max(W,H));
    grd.addColorStop(0,'rgba(0,0,0,0)');
    grd.addColorStop(1,'rgba(0,0,0,.55)');
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,W,H);
  }

  // ---------- Render loop ----------
  function frame(now){
    // Rebuild if large orientation resize
    if(Math.abs(W-lastBuildW)>40 || Math.abs(H-lastBuildH)>40){
      size(); return; // size() calls initScene(); we return to avoid double draw
    }

    // Clear with faint background to keep glow crisp
    ctx.clearRect(0,0,W,H);

    // Subtle grid (depth of field effect via blur)
    ctx.save();
    ctx.filter = 'blur(1.2px)';
    ctx.strokeStyle = 'rgba(150,190,255,.09)';
    ctx.lineWidth = 1;
    const gap = 48;
    for(let x=((W%gap)/2)|0; x<W; x+=gap){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
    }
    for(let y=((H%gap)/2)|0; y<H; y+=gap){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
    }
    ctx.restore();

    // Draw
    drawBoard(now);
    drawBrain(now);
    vignette();

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
